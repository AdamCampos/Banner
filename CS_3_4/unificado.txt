# DUMP UNIFICADO - 2025-08-28 07:45:09
================================================================================
# Arquivo : .NETFramework,Version=v4.8.AssemblyAttributes.cs
# Caminho : C:\Projetos\VisualStudio\Banner\CS_3_4\.NETFramework,Version=v4.8.AssemblyAttributes.cs
# Tamanho : 210 bytes
# Alterado: 08/26/2025 17:34:07
================================================================================

// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETFramework,Version=v4.8", FrameworkDisplayName = ".NET Framework 4.8")]



================================================================================
# Arquivo : AssemblyInfo.cs
# Caminho : C:\Projetos\VisualStudio\Banner\CS_3_4\AssemblyInfo.cs
# Tamanho : 1274 bytes
# Alterado: 08/26/2025 17:34:07
================================================================================

using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("InjectorConsole")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("InjectorConsole")]
[assembly: AssemblyCopyright("Copyright ©  2025")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible
// to COM components.  If you need to access a type in this assembly from
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("552b4678-759f-419a-b6bf-c08f58338813")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version
//      Build Number
//      Revision
//
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]



================================================================================
# Arquivo : CoCreateInstanceExDto.cs
# Caminho : C:\Projetos\VisualStudio\Banner\CS_3_4\CoCreateInstanceExDto.cs
# Tamanho : 938 bytes
# Alterado: 08/27/2025 21:18:13
================================================================================

using System.Collections.Generic;

namespace ComHookLib.Dto
{
    internal class CoCreateInstanceExDto : ComEventBase
    {
        public string api { get; set; } = "CoCreateInstanceEx";

        public string clsid { get; set; }
        public string progId { get; set; }
        public string clsctx { get; set; }
        public int count { get; set; }                // número de IIDs
        public List<string> iids { get; set; }        // lista de "{...}"
        public List<int> multiqi_hr { get; set; }     // HRESULTs de cada IID (opcional)
        public string hr { get; set; }
        public string hr_name { get; set; }
        public double elapsed_ms { get; set; }
        public string kind { get; set; }
        // opcionalmente: uma lista paralela com "iid_names" se quiser popular também
        public List<string> iid_names { get; set; }   // preenchida no enrichment, se desejar
    }
}



================================================================================
# Arquivo : CoGetClassObjectDto.cs
# Caminho : C:\Projetos\VisualStudio\Banner\CS_3_4\CoGetClassObjectDto.cs
# Tamanho : 885 bytes
# Alterado: 08/27/2025 21:17:49
================================================================================

using System.Collections.Generic;

namespace ComHookLib.Dto
{
    internal class CoGetClassObjectDto : ComEventBase
    {
        public string api { get; set; } = "CoGetClassObject";

        public string clsid { get; set; }         // "{...}"
        public string progId { get; set; }        // pode vir null e será resolvido
        public string iid { get; set; }           // "{...}"
        public string iid_name { get; set; }      // preenchido no EnrichIfComEvent
        public string clsctx { get; set; }        // "INPROC_SERVER|..."; normalizado pelo enrichment
        public string hr { get; set; }            // "0x........"
        public string hr_name { get; set; }       // preenchido no enrichment
        public double elapsed_ms { get; set; }
        public string kind { get; set; }          // "ftaerel"/"maybe" via enrichment
    }
}



================================================================================
# Arquivo : ComApis.cs
# Caminho : C:\Projetos\VisualStudio\Banner\CS_3_4\ComApis.cs
# Tamanho : 1049 bytes
# Alterado: 08/27/2025 14:54:23
================================================================================

using System;
using System.Runtime.InteropServices;

namespace ComHookLib.Hooking
{
    // Delegates que refletem as assinaturas nativas de OLE32 (stdcall)
    [UnmanagedFunctionPointer(CallingConvention.StdCall)]
    internal delegate int CoCreateInstance_Delegate(
        ref Guid rclsid,
        IntPtr pUnkOuter,
        ComHookLib.CLSCTX dwClsContext,
        ref Guid riid,
        out IntPtr ppv
    );

    [UnmanagedFunctionPointer(CallingConvention.StdCall)]
    internal delegate int CoGetClassObject_Delegate(
        ref Guid rclsid,
        ComHookLib.CLSCTX dwClsContext,
        IntPtr pServerInfo,   // COSERVERINFO*
        ref Guid riid,
        out IntPtr ppv
    );

    [UnmanagedFunctionPointer(CallingConvention.StdCall)]
    internal delegate int CoCreateInstanceEx_Delegate(
        ref Guid rclsid,
        IntPtr pUnkOuter,
        ComHookLib.CLSCTX dwClsCtx,
        IntPtr pServerInfo,    // COSERVERINFO*
        uint dwCount,
        IntPtr pResults        // MULTI_QI*
    );
}



================================================================================
# Arquivo : ComDecode.cs
# Caminho : C:\Projetos\VisualStudio\Banner\CS_3_4\ComDecode.cs
# Tamanho : 1672 bytes
# Alterado: 08/27/2025 20:09:10
================================================================================

// ComHookLib - ComDecode.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;

namespace ComHookLib
{
    /// <summary>
    /// Utilitários de normalização/legibilidade.
    /// </summary>
    public static class ComDecode
    {
        private static readonly Regex SepRegex = new Regex(@"[\s\|\+\,/\\]+", RegexOptions.Compiled);

        /// <summary>
        /// Normaliza CLSCTX para 1 linha, tokens únicos e ordenados.
        /// Entrada tolerante (null, vazio, quebras, "|", "+", ",", etc).
        /// </summary>
        public static string NormalizeClsctx(string clsctx)
        {
            if (string.IsNullOrWhiteSpace(clsctx))
                return clsctx; // não força nada; só evita exceção

            // remove quebras e normaliza separadores
            var cleaned = clsctx.Replace("\r", " ").Replace("\n", " ");

            // tokeniza por vários separadores
            var tokens = SepRegex
                .Split(cleaned)
                .Where(t => !string.IsNullOrWhiteSpace(t))
                .Select(t => t.Trim())
                .Distinct(StringComparer.OrdinalIgnoreCase)
                .OrderBy(t => t, StringComparer.OrdinalIgnoreCase)
                .ToArray();

            return string.Join("|", tokens);
        }

        /// <summary>
        /// Reduz múltiplos espaços/quebras para uma linha só.
        /// </summary>
        public static string OneLine(string s)
        {
            if (string.IsNullOrEmpty(s)) return s;
            return Regex.Replace(s, @"\s+", " ").Trim();
        }
    }
}



================================================================================
# Arquivo : ComDictionary.cs
# Caminho : C:\Projetos\VisualStudio\Banner\CS_3_4\ComDictionary.cs
# Tamanho : 11670 bytes
# Alterado: 08/27/2025 20:39:49
================================================================================

// ComHookLib - ComDictionary.cs
// T3/T4: resolvers e fallback de registro (x86) para CLSID -> ProgID
// Compatível com C# 7.3

using System;
using System.Collections.Generic;
using System.Globalization;
using Microsoft.Win32;

namespace ComHookLib
{
    /// <summary>
    /// Dicionários e utilidades de resolução de nomes de COM (HRESULT, IID, ProgID, "kind").
    /// </summary>
    public static partial class ComDictionary
    {
        // --------------------------------------------------------------------
        // T4) Fallback de registro para CLSID→ProgID (vista x86)
        // --------------------------------------------------------------------

        /// <summary>
        /// Lê HKCR\CLSID\{clsid}\ProgID (merge), depois HKCU/HKLM\Software\Classes na vista de 32-bit.
        /// Retorna o ProgID ou null se não encontrado.
        /// </summary>
        public static string TryRegistryProgId(string clsid)
        {
            var norm = NormalizeGuidD(clsid);
            if (norm == null) return null;

            var rel = @"CLSID\{" + norm + @"}\ProgID";

            // 1) HKCR (merge) – em processo x86 normalmente já reflete a vista correta
            try
            {
                using (var k = Registry.ClassesRoot.OpenSubKey(rel))
                {
                    var v = k == null ? null : k.GetValue(null) as string; // (Default)
                    if (!string.IsNullOrWhiteSpace(v))
                        return v;
                }
            }
            catch
            {
                // ignore
            }

            // 2) HKCU\Software\Classes (x86)
            var vUser = ReadClasses32(RegistryHive.CurrentUser, rel);
            if (!string.IsNullOrWhiteSpace(vUser))
                return vUser;

            // 3) HKLM\Software\Classes (x86)
            var vMachine = ReadClasses32(RegistryHive.LocalMachine, rel);
            if (!string.IsNullOrWhiteSpace(vMachine))
                return vMachine;

            return null;
        }

        private static string ReadClasses32(RegistryHive hive, string subKeyUnderClasses)
        {
            try
            {
                using (var baseKey = RegistryKey.OpenBaseKey(hive, RegistryView.Registry32))
                using (var k = baseKey.OpenSubKey(@"Software\Classes\" + subKeyUnderClasses))
                {
                    return k == null ? null : (k.GetValue(null) as string);
                }
            }
            catch
            {
                return null;
            }
        }

        // --------------------------------------------------------------------
        // Resolvedores públicos usados pelo logger/enrichment
        // --------------------------------------------------------------------

        /// <summary>
        /// Traduz HRESULT ("0x........") para um nome amigável, ex.: "S_OK".
        /// </summary>
        public static string TryResolveHResult(string hr)
        {
            if (string.IsNullOrWhiteSpace(hr)) return null;

            var canon = CanonHResult(hr);
            string name;
            if (_hresultNames.TryGetValue(canon, out name))
                return name;

            return null;
        }

        /// <summary>
        /// Traduz IID (GUID) para nome conhecido. Fallback para "IID_XXXXXXXX" (8 hex iniciais).
        /// </summary>
        public static string TryResolveIid(string iid)
        {
            var norm = NormalizeGuidD(iid);
            if (norm == null) return null;

            string name;
            if (_iidNames.TryGetValue(norm, out name))
                return name;

            // Fallback legível que você já vinha usando
            return "IID_" + norm.Substring(0, 8);
        }

        /// <summary>
        /// Resolve ProgID a partir do valor já capturado OU via dicionário interno OU (T4) via registro x86.
        /// </summary>
        public static string TryResolveProgId(string clsid, string progId)
        {
            if (!string.IsNullOrWhiteSpace(progId))
                return progId;

            var norm = NormalizeGuidD(clsid);

            // 1) Mapa interno
            if (!string.IsNullOrEmpty(norm))
            {
                string mapped;
                if (_clsid2ProgId.TryGetValue(norm, out mapped) && !string.IsNullOrWhiteSpace(mapped))
                    return mapped;
            }

            // 2) Fallback (T4) – Registro (x86)
            return TryRegistryProgId(clsid);
        }

        /// <summary>
        /// Classificador leve do "kind" para filtros/relatórios.
        /// - "ftaerel" quando ProgID denota FTAlarm*/RnaAe*/AlarmMux*/FTAE
        /// - "maybe" caso contrário.
        /// </summary>
        public static string TryResolveKind(string clsid, string progId)
        {
            // Tenta com o progId fornecido
            if (IsFtaeRelevant(progId))
                return "ftaerel";

            // Sem progId: dá uma olhada no mapa interno para inferir
            var norm = NormalizeGuidD(clsid);
            if (!string.IsNullOrEmpty(norm))
            {
                string mapped;
                if (_clsid2ProgId.TryGetValue(norm, out mapped))
                {
                    if (IsFtaeRelevant(mapped))
                        return "ftaerel";
                }
            }

            return "maybe";
        }

        private static bool IsFtaeRelevant(string progId)
        {
            if (string.IsNullOrWhiteSpace(progId)) return false;
            var p = progId.Trim().ToLowerInvariant();

            // Heurística simples e estável:
            return p.StartsWith("ftalarm", StringComparison.Ordinal) ||
                   p.StartsWith("rnaae", StringComparison.Ordinal) ||
                   p.Contains("ftae") ||
                   p.Contains("alarmmux");
        }

        // --------------------------------------------------------------------
        // Helpers de normalização
        // --------------------------------------------------------------------

        private static string NormalizeGuidD(string v)
        {
            if (string.IsNullOrWhiteSpace(v)) return null;
            v = v.Trim().Trim('{', '}');
            Guid g;
            if (!Guid.TryParse(v, out g))
                return null;

            return g.ToString("D").ToLowerInvariant();
        }

        private static string CanonHResult(string hr)
        {
            var s = hr.Trim();
            if (s.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                uint x;
                if (uint.TryParse(s.Substring(2), NumberStyles.HexNumber, CultureInfo.InvariantCulture, out x))
                    return "0x" + x.ToString("x8");
                return s.ToLowerInvariant();
            }
            // Tenta decimal
            int dec;
            if (int.TryParse(s, NumberStyles.Integer, CultureInfo.InvariantCulture, out dec))
            {
                unchecked
                {
                    return "0x" + ((uint)dec).ToString("x8");
                }
            }
            return s.ToLowerInvariant();
        }

        // --------------------------------------------------------------------
        // Dicionários (T3) - estenda conforme necessário
        // --------------------------------------------------------------------

        // HRESULT básicos usados recorrentemente
        private static readonly Dictionary<string, string> _hresultNames =
            new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
            {
                { "0x00000000", "S_OK" },
                { "0x80004001", "E_NOTIMPL" },
                { "0x80004002", "E_NOINTERFACE" },
                { "0x80004003", "E_POINTER" },
                { "0x80004005", "E_FAIL" },
                { "0x80070005", "E_ACCESSDENIED" },
                { "0x80040110", "CLASS_E_NOAGGREGATION" },
                { "0x80040111", "CLASS_E_CLASSNOTAVAILABLE" },
                { "0x80040112", "CLASS_E_NOTLICENSED" },
                { "0x80040154", "REGDB_E_CLASSNOTREG" },
                { "0x800401F0", "CO_E_NOTINITIALIZED" },
                { "0x800401F3", "CO_E_CLASSSTRING" },
                { "0x800401F6", "CO_E_INVALIDAPARTMENT" },
                { "0x8007000E", "E_OUTOFMEMORY" }
            };

        // Alguns IIDs comuns + o do seu log recente (000001fd…)
        // IIDs básicos e comuns (corrigidos + ampliados)
        private static readonly Dictionary<string, string> _iidNames =
            new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
        {
    // Núcleo COM
    { "00000000-0000-0000-c000-000000000046", "IUnknown" },
    { "00000001-0000-0000-c000-000000000046", "IClassFactory" },
    { "00000003-0000-0000-c000-000000000046", "IMarshal" },

    // Persistência / Monikers / ROT
    { "0000000b-0000-0000-c000-000000000046", "IStorage" },
    { "0000000c-0000-0000-c000-000000000046", "IStream" },
    { "0000000e-0000-0000-c000-000000000046", "IBindCtx" },
    { "0000000f-0000-0000-c000-000000000046", "IMoniker" },
    { "00000010-0000-0000-c000-000000000046", "IRunningObjectTable" },

    { "00000109-0000-0000-c000-000000000046", "IPersistStream" },
    { "0000010b-0000-0000-c000-000000000046", "IPersistFile" },
    { "0000010c-0000-0000-c000-000000000046", "IPersist" },

    // OLE / Dados
    { "0000010e-0000-0000-c000-000000000046", "IDataObject" },
    { "00000112-0000-0000-c000-000000000046", "IOleObject" },

    // Automation / TypeLib
    { "00020400-0000-0000-c000-000000000046", "IDispatch" },
    { "00020401-0000-0000-c000-000000000046", "ITypeInfo" },
    { "00020402-0000-0000-c000-000000000046", "ITypeLib" },
    { "00020403-0000-0000-c000-000000000046", "ITypeComp" },
    { "00020404-0000-0000-c000-000000000046", "IEnumVARIANT" },

    // Serviços / Class Info / Conexões
    { "6d5140c1-7436-11ce-8034-00aa006009fa", "IServiceProvider" },
    { "b196b283-bab4-101a-b69c-00aa00341d07", "IProvideClassInfo" },
    { "b196b284-bab4-101a-b69c-00aa00341d07", "IConnectionPointContainer" },
    { "b196b285-bab4-101a-b69c-00aa00341d07", "IEnumConnectionPoints" },
    { "b196b286-bab4-101a-b69c-00aa00341d07", "IConnectionPoint" },
    { "b196b287-bab4-101a-b69c-00aa00341d07", "IEnumConnections" },

    // Erros (Automation)
    { "1cf2b120-547d-101b-8e65-08002b2bd119", "IErrorInfo" },
    { "df0b3d60-548f-101b-8e65-08002b2bd119", "ISupportErrorInfo" },

    // Extensão útil
    { "a6ef9860-c720-11d0-9337-00a0c90dcaa9", "IDispatchEx" },

    // O que você já tinha citado no log
    { "00000146-0000-0000-c000-000000000046", "IGlobalInterfaceTable" },
    { "000001fd-0000-0000-c000-000000000046", "IComCatalogSCM" } // se aplicável no seu ambiente
        };


        // Mapeamentos internos CLSID -> ProgID (adicione os seus FTAE aqui conforme descubra/precise)
        private static readonly Dictionary<string, string> _clsid2ProgId =
            new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
            {
                // Exemplos ilustrativos:
                // { "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx", "FTAlarm.Manager" },
                // { "yyyyyyyy-yyyy-yyyy-yyyy-yyyyyyyyyyyy", "RnaAe.Provider" },
                // { "zzzzzzzz-zzzz-zzzz-zzzz-zzzzzzzzzzzz", "AlarmMux.Core" }
            };
    }
}



================================================================================
# Arquivo : ComEventBase.cs
# Caminho : C:\Projetos\VisualStudio\Banner\CS_3_4\ComEventBase.cs
# Tamanho : 549 bytes
# Alterado: 08/27/2025 21:27:32
================================================================================

using System;

namespace ComHookLib.Dto
{
    internal class ComEventBase
    {
        public string ts { get; set; } = DateTime.UtcNow.ToString("o");
        public int pid { get; set; } = System.Diagnostics.Process.GetCurrentProcess().Id;
        public uint tid { get; set; } = (uint)Native.GetCurrentThreadId();
        public string schema { get; set; } = "comlog.v2";
        // Observação: build/session_id são adicionados pelo ComLogger.Write nos logs textuais;
        // aqui focamos no payload de evento COM.
    }
}



================================================================================
# Arquivo : ComEvents.cs
# Caminho : C:\Projetos\VisualStudio\Banner\CS_3_4\ComEvents.cs
# Tamanho : 3133 bytes
# Alterado: 08/27/2025 21:58:48
================================================================================

using System;

namespace ComHookLib
{
    /// <summary>
    /// DTOs usados no log: COM (CoGetClassObject/CoCreateInstance/Ex) e UI (WinEvent).
    /// Mantém nomes de propriedades iguais ao JSON atual para retrocompatibilidade.
    /// </summary>
    public static class ComEvents
    {
        // --------------------------- COM ---------------------------

        public sealed class CoGetClassObjectEvent
        {
            public string ts { get; set; }
            public string api { get; set; } = "CoGetClassObject";
            public int pid { get; set; }
            public int tid { get; set; }
            public string clsid { get; set; }
            public string progId { get; set; }
            public string iid { get; set; }
            public string iid_name { get; set; }
            public string clsctx { get; set; }
            public string hr { get; set; }
            public string hr_name { get; set; }
            public double elapsed_ms { get; set; }
            public string kind { get; set; }
        }

        public sealed class CoCreateInstanceEvent
        {
            public string ts { get; set; }
            public string api { get; set; } = "CoCreateInstance";
            public int pid { get; set; }
            public int tid { get; set; }
            public string clsid { get; set; }
            public string progId { get; set; }
            public string iid { get; set; }
            public string iid_name { get; set; }
            public string clsctx { get; set; }
            public string hr { get; set; }
            public string hr_name { get; set; }
            public double elapsed_ms { get; set; }
            public string kind { get; set; }
        }

        public sealed class CoCreateInstanceExEvent
        {
            public string ts { get; set; }
            public string api { get; set; } = "CoCreateInstanceEx";
            public int pid { get; set; }
            public int tid { get; set; }
            public string clsid { get; set; }
            public string progId { get; set; }
            public string clsctx { get; set; }
            public uint count { get; set; }
            public string[] iids { get; set; }
            public string[] iid_names { get; set; }
            public int[] multiqi_hr { get; set; }
            public string hr { get; set; }
            public string hr_name { get; set; }
            public double elapsed_ms { get; set; }
            public string kind { get; set; }
        }

        // ---------------------------- UI ---------------------------

        public sealed class UiWindowEvent
        {
            public string ts { get; set; }
            public string evt { get; set; }
            public string kind { get; set; }
            public int pid { get; set; }
            public int tid { get; set; }
            public string hwnd { get; set; }
            public string cls { get; set; }
            public string title { get; set; }
            public uint threadId { get; set; }
        }
    }
}



================================================================================
# Arquivo : ComHookLib.csproj
# Caminho : C:\Projetos\VisualStudio\Banner\CS_3_4\ComHookLib.csproj
# Tamanho : 3889 bytes
# Alterado: 08/27/2025 21:18:40
================================================================================

<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform>x86</Platform>
    <ProjectGuid>{79D14332-E526-4381-BAED-53A95B23A82A}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>ComHookLib</RootNamespace>
    <AssemblyName>ComHookLib</AssemblyName>
    <TargetFrameworkVersion>v4.8</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <Deterministic>true</Deterministic>
    <Platforms>x86</Platforms>
    <PlatformTarget>x86</PlatformTarget>
    <Prefer32Bit>true</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x86'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\x86\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <LangVersion>7.3</LangVersion>
    <ErrorReport>prompt</ErrorReport>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x86'">
    <OutputPath>bin\x86\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <LangVersion>7.3</LangVersion>
    <ErrorReport>prompt</ErrorReport>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="EasyHook, Version=2.7.7097.0, Culture=neutral, PublicKeyToken=4b580fca19d0b0c5, processorArchitecture=MSIL">
      <HintPath>..\Banner\packages\EasyHook.2.7.7097\lib\net40\EasyHook.dll</HintPath>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Runtime.Remoting" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Net.Http" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="ComDecode.cs" />
    <Compile Include="ComDictionary.cs" />
    <Compile Include="ComEvents.cs" />
    <Compile Include="ComLogIpc.cs" />
    <Compile Include="DTO\CoCreateInstanceExDto.cs" />
    <Compile Include="DTO\CoGetClassObjectDto.cs" />
    <Compile Include="DTO\ComEventBase.cs" />
    <Compile Include="DTO\UiEventDto.cs" />
    <Compile Include="Hooking\ComApis.cs" />
    <Compile Include="Hooking\EasyHookHelper.cs" />
    <Compile Include="Jsonl.cs" />
    <Compile Include="MultiSink.cs" />
    <Compile Include="Native.cs" />
    <Compile Include="Program.cs" />
    <Compile Include="ComHooks.cs" />
    <Compile Include="ComLogger.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="RelevantFileSink.cs" />
    <Compile Include="RemoteEntry.cs" />
    <Compile Include="UiHook.cs" />
  </ItemGroup>
  <!-- Somente dependências x86 copiadas para a saída -->
  <ItemGroup>
    <Content Include="EasyHook32.dll">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Content>
    <Content Include="EasyHook32Svc.exe">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Content>
    <Content Include="EasyLoad32.dll">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Content>
  </ItemGroup>
  <ItemGroup>
    <None Include="packages.config" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
</Project>


================================================================================
# Arquivo : ComHooks.cs
# Caminho : C:\Projetos\VisualStudio\Banner\CS_3_4\ComHooks.cs
# Tamanho : 8934 bytes
# Alterado: 08/27/2025 21:59:26
================================================================================

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using EasyHook;
using ComHookLib.Hooking;

namespace ComHookLib
{
    internal static class ComHooks
    {
        private static bool _installed;
        private static ILogger _logger;

        private static LocalHook _hkCCI, _hkCCIEx, _hkCGCO;
        private static CoCreateInstance_Delegate _origCCI;
        private static CoCreateInstanceEx_Delegate _origCCIEx;
        private static CoGetClassObject_Delegate _origCGCO;

        public static void Install(ILogger logger)
        {
            if (_installed) return;
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));

            try
            {
                _origCCI = EasyHookHelper.GetOriginalDelegate<CoCreateInstance_Delegate>("ole32.dll", "CoCreateInstance");
                _origCCIEx = EasyHookHelper.GetOriginalDelegate<CoCreateInstanceEx_Delegate>("ole32.dll", "CoCreateInstanceEx");
                _origCGCO = EasyHookHelper.GetOriginalDelegate<CoGetClassObject_Delegate>("ole32.dll", "CoGetClassObject");

                _hkCCI = EasyHookHelper.CreateHook("ole32.dll", "CoCreateInstance", new CoCreateInstance_Delegate(CCICallback), null);
                _hkCCIEx = EasyHookHelper.CreateHook("ole32.dll", "CoCreateInstanceEx", new CoCreateInstanceEx_Delegate(CCIExCallback), null);
                _hkCGCO = EasyHookHelper.CreateHook("ole32.dll", "CoGetClassObject", new CoGetClassObject_Delegate(CGCOCallback), null);

                _installed = true;
                _logger.Info("COM hooks instalados com sucesso (CoCreateInstance/Ex, CoGetClassObject).");
            }
            catch (Exception ex)
            {
                _logger.Error(ex, "Falha ao instalar hooks COM.");
            }
        }

        private static int CCICallback(ref Guid rclsid, IntPtr pUnkOuter, CLSCTX ctx, ref Guid riid, out IntPtr ppv)
        {
            var pid = Process.GetCurrentProcess().Id;
            var tid = (int)Native.GetCurrentThreadId();
            string progIdRaw = Native.ProgIdFromClsidSafe(rclsid);
            string clsidStr = rclsid.ToString("D");
            string iidStr = riid.ToString("D");

            var sw = Stopwatch.StartNew();
            int hr = 0;
            ppv = IntPtr.Zero;

            try
            {
                hr = _origCCI(ref rclsid, pUnkOuter, ctx, ref riid, out ppv);
                return hr;
            }
            finally
            {
                sw.Stop();
                var dto = new ComEvents.CoCreateInstanceEvent
                {
                    ts = DateTime.UtcNow.ToString("o"),
                    api = "CoCreateInstance",
                    pid = pid,
                    tid = tid,
                    clsid = clsidStr,
                    progId = ComDictionary.TryResolveProgId(clsidStr, progIdRaw),
                    iid = iidStr,
                    iid_name = ComDictionary.TryResolveIid(iidStr),
                    clsctx = ctx.ToString(),
                    hr = $"0x{hr:X8}",
                    hr_name = ComDictionary.TryResolveHResult($"0x{hr:X8}"),
                    elapsed_ms = sw.Elapsed.TotalMilliseconds,
                    kind = ComDictionary.TryResolveKind(clsidStr, progIdRaw)
                };
                SafeLog(dto);
            }
        }

        private static int CCIExCallback(ref Guid rclsid, IntPtr pUnkOuter, CLSCTX ctx, IntPtr pServerInfo, uint dwCount, IntPtr pResults)
        {
            var pid = Process.GetCurrentProcess().Id;
            var tid = (int)Native.GetCurrentThreadId();
            string progIdRaw = Native.ProgIdFromClsidSafe(rclsid);
            string clsidStr = rclsid.ToString("D");

            Guid[] iidsIn = ReadIidsFromMultiQi(pResults, dwCount);
            int hr = 0;
            var sw = Stopwatch.StartNew();

            try
            {
                hr = _origCCIEx(ref rclsid, pUnkOuter, ctx, pServerInfo, dwCount, pResults);
                return hr;
            }
            finally
            {
                sw.Stop();
                int[] hrsPerQi = ReadHResultsFromMultiQi(pResults, dwCount);

                string[] iidStrs = new string[iidsIn.Length];
                string[] iidNames = new string[iidsIn.Length];
                for (int i = 0; i < iidsIn.Length; i++)
                {
                    var s = iidsIn[i].ToString("D");
                    iidStrs[i] = s;
                    iidNames[i] = ComDictionary.TryResolveIid(s);
                }

                var dto = new ComEvents.CoCreateInstanceExEvent
                {
                    ts = DateTime.UtcNow.ToString("o"),
                    api = "CoCreateInstanceEx",
                    pid = pid,
                    tid = tid,
                    clsid = clsidStr,
                    progId = ComDictionary.TryResolveProgId(clsidStr, progIdRaw),
                    clsctx = ctx.ToString(),
                    count = dwCount,
                    iids = iidStrs,
                    iid_names = iidNames,
                    multiqi_hr = hrsPerQi,
                    hr = $"0x{hr:X8}",
                    hr_name = ComDictionary.TryResolveHResult($"0x{hr:X8}"),
                    elapsed_ms = sw.Elapsed.TotalMilliseconds,
                    kind = ComDictionary.TryResolveKind(clsidStr, progIdRaw)
                };
                SafeLog(dto);
            }
        }

        private static int CGCOCallback(ref Guid rclsid, CLSCTX ctx, IntPtr pServerInfo, ref Guid riid, out IntPtr ppv)
        {
            var pid = Process.GetCurrentProcess().Id;
            var tid = (int)Native.GetCurrentThreadId();
            string progIdRaw = Native.ProgIdFromClsidSafe(rclsid);
            string clsidStr = rclsid.ToString("D");
            string iidStr = riid.ToString("D");

            var sw = Stopwatch.StartNew();
            int hr = 0;
            ppv = IntPtr.Zero;

            try
            {
                hr = _origCGCO(ref rclsid, ctx, pServerInfo, ref riid, out ppv);
                return hr;
            }
            finally
            {
                sw.Stop();
                var dto = new ComEvents.CoGetClassObjectEvent
                {
                    ts = DateTime.UtcNow.ToString("o"),
                    api = "CoGetClassObject",
                    pid = pid,
                    tid = tid,
                    clsid = clsidStr,
                    progId = ComDictionary.TryResolveProgId(clsidStr, progIdRaw),
                    iid = iidStr,
                    iid_name = ComDictionary.TryResolveIid(iidStr),
                    clsctx = ctx.ToString(),
                    hr = $"0x{hr:X8}",
                    hr_name = ComDictionary.TryResolveHResult($"0x{hr:X8}"),
                    elapsed_ms = sw.Elapsed.TotalMilliseconds,
                    kind = ComDictionary.TryResolveKind(clsidStr, progIdRaw)
                };
                SafeLog(dto);
            }
        }

        private static Guid[] ReadIidsFromMultiQi(IntPtr pResults, uint count)
        {
            if (pResults == IntPtr.Zero || count == 0) return Array.Empty<Guid>();
            var list = new Guid[count];
            int size = Marshal.SizeOf(typeof(MULTI_QI));
            for (int i = 0; i < count; i++)
            {
                IntPtr cur = IntPtr.Add(pResults, i * size);
                MULTI_QI qi;
                try { qi = Marshal.PtrToStructure<MULTI_QI>(cur); }
                catch { continue; }

                try
                {
                    if (qi.pIID != IntPtr.Zero)
                    {
                        var iid = Marshal.PtrToStructure<Guid>(qi.pIID);
                        list[i] = iid;
                    }
                }
                catch { }
            }
            return list;
        }

        private static int[] ReadHResultsFromMultiQi(IntPtr pResults, uint count)
        {
            if (pResults == IntPtr.Zero || count == 0) return Array.Empty<int>();
            var list = new int[count];
            int size = Marshal.SizeOf(typeof(MULTI_QI));
            for (int i = 0; i < count; i++)
            {
                IntPtr cur = IntPtr.Add(pResults, i * size);
                try
                {
                    var qi = Marshal.PtrToStructure<MULTI_QI>(cur);
                    list[i] = qi.hr;
                }
                catch { }
            }
            return list;
        }

        private static void SafeLog(object payload)
        {
            try { _logger?.Log(payload); }
            catch { try { _logger?.Warn("Falha ao logar payload COM."); } catch { } }
        }
    }
}



================================================================================
# Arquivo : ComLogger.cs
# Caminho : C:\Projetos\VisualStudio\Banner\CS_3_4\ComLogger.cs
# Tamanho : 11681 bytes
# Alterado: 08/28/2025 07:04:54
================================================================================

using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Reflection;

namespace ComHookLib
{
    // NÃO declarar ILogSink aqui — já existe (ex.: em ComLogIpc.cs):
    // public interface ILogSink { void WriteLine(string line); }

    public interface ILogger
    {
        void Info(string message, params object[] args);
        void Warn(string message, params object[] args);
        void Error(string message, params object[] args);
        void Error(Exception ex, string message, params object[] args);
        void Log(object dto);
    }

    internal sealed class ComLogger : ILogger
    {
        private readonly ILogSink _sink;
        private readonly string _sessionId;

        // Metadados fixos do log
        private const string Schema = "comlog.v2";
        private static readonly string BuildVersion = GetBuildVersion();

        public ComLogger(ILogSink sink, string sessionId)
        {
            if (sink == null) throw new ArgumentNullException(nameof(sink));
            _sink = sink;
            _sessionId = sessionId ?? "unknown";
        }

        public void Info(string message, params object[] args) { Write("info", null, message, args); }
        public void Warn(string message, params object[] args) { Write("warn", null, message, args); }
        public void Error(string message, params object[] args) { Write("error", null, message, args); }
        public void Error(Exception ex, string message, params object[] args) { Write("error", ex, message, args); }

        /// <summary>
        /// Ponto único de saída de eventos (DTOs). Aplica enriquecimento (HRESULT/IID/ProgID/kind/CLSCTX).
        /// </summary>
        public void Log(object dto)
        {
            if (dto == null) return;

            object enriched = dto;
            try
            {
                enriched = EnrichIfComEvent(dto);
            }
            catch (Exception ex)
            {
                _sink.WriteLine(Jsonl.Serialize(new
                {
                    ts = DateTime.UtcNow.ToString("o"),
                    level = "warn",
                    schema = "comlog.v2",
                    build = BuildVersion,  // <-- corrigido
                    session_id = _sessionId,
                    pid = System.Diagnostics.Process.GetCurrentProcess().Id,
                    tid = Native.GetCurrentThreadId(),
                    msg = "Falha no EnrichIfComEvent.",
                    err = ex.ToString()
                }));
                return;
            }

            try
            {
                _sink.WriteLine(Jsonl.Serialize(enriched));
            }
            catch (Exception ex)
            {
                _sink.WriteLine(Jsonl.Serialize(new
                {
                    ts = DateTime.UtcNow.ToString("o"),
                    level = "warn",
                    schema = "comlog.v2",
                    build = BuildVersion, // <-- corrigido
                    session_id = _sessionId,
                    pid = System.Diagnostics.Process.GetCurrentProcess().Id,
                    tid = Native.GetCurrentThreadId(),
                    msg = "Falha ao logar payload COM.",
                    err = ex.ToString()
                }));
            }
        }


        // =========================================================================
        // Enriquecimento COM: resolve hr_name, iid_name, progId (com fallback T4), kind e normaliza clsctx (T5)
        // =========================================================================
        // Dentro de ComLogger.cs
        // =========================================================================
        // Enriquecimento COM tolerante a tipos anônimos (sem setter)
        // - Se tiver setter, grava na própria DTO;
        // - Caso contrário, cria um Dictionary<string,object> com os campos extra.
        // =========================================================================
        private object EnrichIfComEvent(object dto)
        {
            if (dto == null) return null;

            var t = dto.GetType();

            // Só enriquece COM se tiver "api" e "clsid"
            var apiProp = t.GetProperty("api");
            var clsidProp = t.GetProperty("clsid");
            if (apiProp == null || clsidProp == null)
                return dto;

            var clsid = clsidProp.GetValue(dto) as string;

            // (1) ProgID (T3 + T4)
            var progIdProp = t.GetProperty("progId");
            var progIdIn = progIdProp != null ? progIdProp.GetValue(dto) as string : null;
            var progIdResolved = ComDictionary.TryResolveProgId(clsid, progIdIn);
            if (progIdProp != null && progIdProp.CanWrite &&
                !string.Equals(progIdResolved, progIdIn, StringComparison.Ordinal))
            {
                progIdProp.SetValue(dto, progIdResolved);
            }

            // (2) HRESULT legível
            var hrProp = t.GetProperty("hr");
            var hrNameProp = t.GetProperty("hr_name");
            if (hrProp != null && hrNameProp != null && hrNameProp.CanWrite)
            {
                var hrStr = hrProp.GetValue(dto) as string;
                var hrName = ComDictionary.TryResolveHResult(hrStr);
                if (!string.IsNullOrEmpty(hrName))
                    hrNameProp.SetValue(dto, hrName);
            }

            // (3) IID legível
            var iidProp = t.GetProperty("iid");
            var iidNameProp = t.GetProperty("iid_name");
            if (iidProp != null && iidNameProp != null && iidNameProp.CanWrite)
            {
                var iid = iidProp.GetValue(dto) as string;
                var iidName = ComDictionary.TryResolveIid(iid);
                if (!string.IsNullOrEmpty(iidName))
                    iidNameProp.SetValue(dto, iidName);
            }

            // (3b) Lista de iids (CoCreateInstanceEx): popular iid_names se existir
            var iidsProp = t.GetProperty("iids");
            var iidNamesListProp = t.GetProperty("iid_names");
            if (iidsProp != null && iidNamesListProp != null && iidNamesListProp.CanWrite)
            {
                var iidsVal = iidsProp.GetValue(dto) as System.Collections.IEnumerable;
                if (iidsVal != null)
                {
                    var names = new System.Collections.Generic.List<string>();
                    foreach (var o in iidsVal)
                        names.Add(ComDictionary.TryResolveIid(o as string));

                    // 👇 AQUI está o pulo do gato:
                    iidNamesListProp.SetValue(dto, names.ToArray()); // em vez de List<string>
                }
            }

            // (4) CLSCTX normalizado (T5)
            var clsctxProp = t.GetProperty("clsctx");
            if (clsctxProp != null && clsctxProp.CanWrite)
            {
                var raw = clsctxProp.GetValue(dto) as string;
                var norm = ComDecode.NormalizeClsctx(raw); // sua função existente
                if (!string.IsNullOrEmpty(norm))
                    clsctxProp.SetValue(dto, norm);
            }

            // (5) kind (clsid + progId resolvido)
            var kindProp = t.GetProperty("kind");
            if (kindProp != null && kindProp.CanWrite)
            {
                var kind = ComDictionary.TryResolveKind(clsid, progIdResolved);
                if (!string.IsNullOrEmpty(kind))
                    kindProp.SetValue(dto, kind);
            }

            return dto;
        }




        // =========================================================================
        // Infra de logging "texto" → JSONL
        // =========================================================================
        private void Write(string level, Exception ex, string message, params object[] args)
        {
            string text = SafeFormat(message, args);
            var payload = new
            {
                ts = DateTime.UtcNow.ToString("o", CultureInfo.InvariantCulture),
                level = level,
                schema = Schema,
                build = BuildVersion,
                session_id = _sessionId,
                pid = Process.GetCurrentProcess().Id,
                tid = Native.GetCurrentThreadId(),
                msg = text,
                err = ex != null ? ex.ToString() : null
            };
            _sink.WriteLine(Jsonl.Serialize(payload));
        }

        private static string SafeFormat(string message, object[] args)
        {
            try
            {
                return (args != null && args.Length > 0)
                    ? string.Format(CultureInfo.InvariantCulture, message, args)
                    : message;
            }
            catch
            {
                return message + " " + string.Join(" | ", args ?? Array.Empty<object>());
            }
        }

        // =========================================================================
        // Helpers de DTO → Dictionary<string, object> (mantidos por compatibilidade)
        // =========================================================================
        private static Dictionary<string, object> ToDictionary(object dto)
        {
            if (dto is IDictionary asDict)
            {
                var copy = new Dictionary<string, object>(StringComparer.OrdinalIgnoreCase);
                foreach (DictionaryEntry kv in asDict)
                {
                    var key = kv.Key?.ToString() ?? string.Empty;
                    copy[key] = kv.Value;
                }
                return copy;
            }

            var map = new Dictionary<string, object>(StringComparer.OrdinalIgnoreCase);
            var props = dto.GetType().GetProperties(BindingFlags.Public | BindingFlags.Instance);
            for (int i = 0; i < props.Length; i++)
            {
                var p = props[i];
                if (!p.CanRead) continue;
                if (p.GetIndexParameters().Length != 0) continue;

                try { map[p.Name] = p.GetValue(dto, null); }
                catch { /* ignora propriedades que lançam */ }
            }
            return map;
        }

        private static string GetString(Dictionary<string, object> map, string key)
        {
            object v;
            if (map.TryGetValue(key, out v) && v != null)
                return v as string ?? Convert.ToString(v, CultureInfo.InvariantCulture);
            return null;
        }

        private static string FirstNonEmpty(params string[] values)
        {
            if (values == null) return null;
            for (int i = 0; i < values.Length; i++)
                if (!string.IsNullOrWhiteSpace(values[i]))
                    return values[i];
            return null;
        }

        private static string GetBuildVersion()
        {
            try
            {
                var asm = typeof(ComLogger).Assembly;
                var fvi = FileVersionInfo.GetVersionInfo(asm.Location);
                return string.IsNullOrWhiteSpace(fvi.FileVersion)
                    ? (asm.GetName().Version != null ? asm.GetName().Version.ToString() : "0.0.0.0")
                    : fvi.FileVersion;
            }
            catch
            {
                return "0.0.0.0";
            }
        }
    }
}



================================================================================
# Arquivo : ComLogIpc.cs
# Caminho : C:\Projetos\VisualStudio\Banner\CS_3_4\ComLogIpc.cs
# Tamanho : 3135 bytes
# Alterado: 08/27/2025 12:37:41
================================================================================

using System;
using System.IO;
using System.IO.Pipes;
using System.Text;

namespace ComHookLib
{
    internal interface ILogSink : IDisposable
    {
        void WriteLine(string line);
    }

    internal sealed class ComLogIpc : ILogSink
    {
        private readonly string _pipeName;
        private readonly string _fallbackFile;
        private NamedPipeClientStream _pipe;
        private StreamWriter _writer;
        private readonly object _sync = new object();
        private volatile bool _useFile;

        public ComLogIpc(string pipeName, string fallbackFile)
        {
            _pipeName = string.IsNullOrWhiteSpace(pipeName) ? "FTAEPipe" : pipeName;
            _fallbackFile = string.IsNullOrWhiteSpace(fallbackFile)
                ? Path.Combine(Path.GetTempPath(), "ftaelog.log")
                : fallbackFile;

            TryConnectPipe();
        }

        private void TryConnectPipe()
        {
            try
            {
                _pipe = new NamedPipeClientStream(".", _pipeName, PipeDirection.Out, PipeOptions.Asynchronous);
                _pipe.Connect(50); // tenta rápido; se não houver servidor, cai para arquivo
                _writer = new StreamWriter(_pipe, new UTF8Encoding(false));
                _writer.AutoFlush = true;
                _useFile = false;
            }
            catch
            {
                // Fallback para arquivo
                string dir = Path.GetDirectoryName(_fallbackFile);
                if (string.IsNullOrEmpty(dir)) dir = Path.GetTempPath();
                Directory.CreateDirectory(dir);

                _writer = new StreamWriter(
                    new FileStream(_fallbackFile, FileMode.Append, FileAccess.Write, FileShare.ReadWrite),
                    new UTF8Encoding(false)
                );
                _writer.AutoFlush = true;
                _useFile = true;
            }
        }

        public void WriteLine(string line)
        {
            if (string.IsNullOrEmpty(line)) return;

            lock (_sync)
            {
                try
                {
                    _writer.WriteLine(line);
                }
                catch
                {
                    if (!_useFile)
                    {
                        // pipeline caiu; reabrir como arquivo
                        try { if (_writer != null) _writer.Dispose(); } catch { }
                        _writer = new StreamWriter(
                            new FileStream(_fallbackFile, FileMode.Append, FileAccess.Write, FileShare.ReadWrite),
                            new UTF8Encoding(false)
                        );
                        _writer.AutoFlush = true;
                        _useFile = true;
                        _writer.WriteLine(line);
                    }
                }
            }
        }

        public void Dispose()
        {
            try { if (_writer != null) _writer.Dispose(); } catch { }
            try { if (_pipe != null) _pipe.Dispose(); } catch { }
        }
    }
}



================================================================================
# Arquivo : EasyHookHelper.cs
# Caminho : C:\Projetos\VisualStudio\Banner\CS_3_4\EasyHookHelper.cs
# Tamanho : 1360 bytes
# Alterado: 08/27/2025 14:54:37
================================================================================

using System;
using System.Runtime.InteropServices;
using EasyHook;

namespace ComHookLib.Hooking
{
    internal static class EasyHookHelper
    {
        public static LocalHook CreateHook<TDelegate>(string module, string procName, TDelegate hookHandler, object callback)
            where TDelegate : Delegate
        {
            if (hookHandler == null) throw new ArgumentNullException(nameof(hookHandler));

            IntPtr addr = LocalHook.GetProcAddress(module, procName);
            if (addr == IntPtr.Zero)
                throw new InvalidOperationException($"GetProcAddress falhou: {module}!{procName}");

            var hook = LocalHook.Create(addr, hookHandler, callback);

            // Permitir em todos os threads (nenhum excluído)
            hook.ThreadACL.SetExclusiveACL(Array.Empty<int>());

            return hook;
        }

        public static TDelegate GetOriginalDelegate<TDelegate>(string module, string procName)
            where TDelegate : Delegate
        {
            IntPtr addr = LocalHook.GetProcAddress(module, procName);
            if (addr == IntPtr.Zero)
                throw new InvalidOperationException($"GetProcAddress falhou: {module}!{procName}");

            return (TDelegate)Marshal.GetDelegateForFunctionPointer(addr, typeof(TDelegate));
        }
    }
}



================================================================================
# Arquivo : InjectorConsole.csproj
# Caminho : C:\Projetos\VisualStudio\Banner\CS_3_4\InjectorConsole.csproj
# Tamanho : 3485 bytes
# Alterado: 08/27/2025 09:02:36
================================================================================

<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />

  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform>x86</Platform>
    <ProjectGuid>{552B4678-759F-419A-B6BF-C08F58338813}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <RootNamespace>InjectorConsole</RootNamespace>
    <AssemblyName>InjectorConsole</AssemblyName>
    <TargetFrameworkVersion>v4.8</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
    <Deterministic>true</Deterministic>
    <Platforms>x86</Platforms>
    <PlatformTarget>x86</PlatformTarget>
    <Prefer32Bit>true</Prefer32Bit>
  </PropertyGroup>

  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x86'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\x86\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <LangVersion>7.3</LangVersion>
    <ErrorReport>prompt</ErrorReport>
  </PropertyGroup>

  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x86'">
    <OutputPath>bin\x86\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <LangVersion>7.3</LangVersion>
    <ErrorReport>prompt</ErrorReport>
  </PropertyGroup>

  <ItemGroup>
    <Reference Include="EasyHook, Version=2.7.7097.0, Culture=neutral, PublicKeyToken=4b580fca19d0b0c5, processorArchitecture=MSIL">
      <HintPath>..\Banner\packages\EasyHook.2.7.7097\lib\net40\EasyHook.dll</HintPath>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Runtime.Remoting" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Net.Http" />
    <Reference Include="System.Xml" />
  </ItemGroup>

  <ItemGroup>
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
  </ItemGroup>

  <ItemGroup>
    <None Include="App.config" />
    <None Include="packages.config" />
  </ItemGroup>

  <!-- Somente dependências x86 copiadas para a saída -->
  <ItemGroup>
    <Content Include="EasyHook32.dll">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Content>
    <Content Include="EasyHook32Svc.exe">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Content>
    <Content Include="EasyLoad32.dll">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Content>
  </ItemGroup>

  <ItemGroup>
    <WCFMetadata Include="Connected Services\" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\ComHookLib\ComHookLib.csproj">
      <Project>{79d14332-e526-4381-baed-53a95b23a82a}</Project>
      <Name>ComHookLib</Name>
    </ProjectReference>
  </ItemGroup>

  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
</Project>



================================================================================
# Arquivo : Jsonl.cs
# Caminho : C:\Projetos\VisualStudio\Banner\CS_3_4\Jsonl.cs
# Tamanho : 7101 bytes
# Alterado: 08/27/2025 12:46:19
================================================================================

using System;
using System.Collections;
using System.Globalization;
using System.Reflection;
using System.Text;

namespace ComHookLib
{
    internal static class Jsonl
    {
        // Profundidade máxima para evitar ciclos acidentais
        private const int MaxDepth = 6;

        public static string Serialize(object obj)
        {
            try
            {
                var sb = new StringBuilder(256);
                WriteValue(sb, obj, 0);
                return sb.ToString();
            }
            catch
            {
                // Fallback mínimo para não perder logs
                return "{\"error\":\"json_serialize_failed\"}";
            }
        }

        private static void WriteValue(StringBuilder sb, object value, int depth)
        {
            if (depth > MaxDepth)
            {
                sb.Append("\"#depth\"");
                return;
            }

            if (value == null)
            {
                sb.Append("null");
                return;
            }

            // Tipos primários rápidos
            var t = value.GetType();

            if (value is string s)
            {
                WriteString(sb, s);
                return;
            }

            if (value is bool b)
            {
                sb.Append(b ? "true" : "false");
                return;
            }

            if (IsNumber(t))
            {
                sb.Append(Convert.ToString(value, CultureInfo.InvariantCulture));
                return;
            }

            if (value is DateTime dt)
            {
                // ISO 8601
                sb.Append('"').Append(dt.ToUniversalTime().ToString("o", CultureInfo.InvariantCulture)).Append('"');
                return;
            }

            if (value is DateTimeOffset dto)
            {
                sb.Append('"').Append(dto.ToUniversalTime().ToString("o", CultureInfo.InvariantCulture)).Append('"');
                return;
            }

            if (value is Guid g)
            {
                sb.Append('"').Append(g.ToString()).Append('"');
                return;
            }

            if (t.IsEnum)
            {
                WriteString(sb, Convert.ToString(value, CultureInfo.InvariantCulture));
                return;
            }

            if (value is byte[] bytes)
            {
                WriteString(sb, Convert.ToBase64String(bytes));
                return;
            }

            // IDictionary
            var asDict = value as IDictionary;
            if (asDict != null)
            {
                WriteDictionary(sb, asDict, depth);
                return;
            }

            // IEnumerable (array/list)
            var asEnum = value as IEnumerable;
            if (asEnum != null && !(value is string))
            {
                WriteArray(sb, asEnum, depth);
                return;
            }

            // Objeto com propriedades públicas
            WriteObject(sb, value, depth);
        }

        private static void WriteDictionary(StringBuilder sb, IDictionary dict, int depth)
        {
            sb.Append('{');
            bool first = true;
            foreach (DictionaryEntry kv in dict)
            {
                if (!first) sb.Append(',');
                first = false;
                // Forçamos chave como string
                WriteString(sb, Convert.ToString(kv.Key, CultureInfo.InvariantCulture) ?? string.Empty);
                sb.Append(':');
                WriteValue(sb, kv.Value, depth + 1);
            }
            sb.Append('}');
        }

        private static void WriteArray(StringBuilder sb, IEnumerable seq, int depth)
        {
            sb.Append('[');
            bool first = true;
            foreach (var item in seq)
            {
                if (!first) sb.Append(',');
                first = false;
                WriteValue(sb, item, depth + 1);
            }
            sb.Append(']');
        }

        private static void WriteObject(StringBuilder sb, object obj, int depth)
        {
            sb.Append('{');
            bool first = true;

            // Propriedades públicas com getter, sem indexadores
            var props = obj.GetType().GetProperties(BindingFlags.Public | BindingFlags.Instance);
            for (int i = 0; i < props.Length; i++)
            {
                var p = props[i];
                if (!p.CanRead) continue;
                if (p.GetIndexParameters().Length != 0) continue;

                object val;
                try
                {
                    val = p.GetValue(obj, null);
                }
                catch
                {
                    continue; // ignora propriedades que lançam
                }

                if (!first) sb.Append(',');
                first = false;

                WriteString(sb, p.Name);
                sb.Append(':');
                WriteValue(sb, val, depth + 1);
            }

            sb.Append('}');
        }

        private static void WriteString(StringBuilder sb, string s)
        {
            if (s == null) { sb.Append("null"); return; }

            sb.Append('"');
            for (int i = 0; i < s.Length; i++)
            {
                var ch = s[i];
                switch (ch)
                {
                    case '\"': sb.Append("\\\""); break;
                    case '\\': sb.Append("\\\\"); break;
                    case '\b': sb.Append("\\b"); break;
                    case '\f': sb.Append("\\f"); break;
                    case '\n': sb.Append("\\n"); break;
                    case '\r': sb.Append("\\r"); break;
                    case '\t': sb.Append("\\t"); break;
                    default:
                        if (ch < 32 || ch > 0x7E)
                        {
                            sb.Append("\\u").Append(((int)ch).ToString("x4"));
                        }
                        else
                        {
                            sb.Append(ch);
                        }
                        break;
                }
            }
            sb.Append('"');
        }

        private static bool IsNumber(Type t)
        {
            // cobre inteiros e ponto flutuante
            var tc = Type.GetTypeCode(t);
            switch (tc)
            {
                case TypeCode.SByte:
                case TypeCode.Byte:
                case TypeCode.Int16:
                case TypeCode.UInt16:
                case TypeCode.Int32:
                case TypeCode.UInt32:
                case TypeCode.Int64:
                case TypeCode.UInt64:
                case TypeCode.Single:
                case TypeCode.Double:
                case TypeCode.Decimal:
                    return true;
                default:
                    return false;
            }
        }
    }
}



================================================================================
# Arquivo : MultiSink.cs
# Caminho : C:\Projetos\VisualStudio\Banner\CS_3_4\MultiSink.cs
# Tamanho : 815 bytes
# Alterado: 08/27/2025 19:47:20
================================================================================

// ComHookLib - MultiSink.cs
// Encadeia 2+ sinks existentes.

using System;
using System.Collections.Generic;

namespace ComHookLib
{
    internal sealed class MultiSink : ILogSink, IDisposable
    {
        private readonly List<ILogSink> _sinks;

        internal MultiSink(params ILogSink[] sinks)
        {
            _sinks = new List<ILogSink>(sinks ?? new ILogSink[0]);
        }

        public void WriteLine(string line)
        {
            for (int i = 0; i < _sinks.Count; i++)
                _sinks[i].WriteLine(line);
        }

        public void Dispose()
        {
            for (int i = 0; i < _sinks.Count; i++)
            {
                var d = _sinks[i] as IDisposable;
                if (d != null) d.Dispose();
            }
        }
    }
}



================================================================================
# Arquivo : Native.cs
# Caminho : C:\Projetos\VisualStudio\Banner\CS_3_4\Native.cs
# Tamanho : 3857 bytes
# Alterado: 08/27/2025 14:55:06
================================================================================

using System;
using System.Runtime.InteropServices;
using System.Text;

namespace ComHookLib
{
    [Flags]
    internal enum CLSCTX : uint
    {
        INPROC_SERVER = 0x1,
        INPROC_HANDLER = 0x2,
        LOCAL_SERVER = 0x4,
        INPROC_SERVER16 = 0x8,
        REMOTE_SERVER = 0x10,
        INPROC_HANDLER16 = 0x20,
        NO_CODE_DOWNLOAD = 0x400,
        NO_CUSTOM_MARSHAL = 0x1000,
        ENABLE_CODE_DOWNLOAD = 0x2000,
        NO_FAILURE_LOG = 0x4000,
        DISABLE_AAA = 0x8000,
        ENABLE_AAA = 0x10000,
        FROM_DEFAULT_CONTEXT = 0x20000,
        ACTIVATE_32_BIT_SERVER = 0x40000,
        ACTIVATE_64_BIT_SERVER = 0x80000,
        ENABLE_CLOAKING = 0x100000,
        APPCONTAINER = 0x400000,
        ACTIVATE_AAA_AS_IU = 0x800000,
        PS_DLL = 0x80000000
    }

    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    internal struct COSERVERINFO
    {
        public uint dwReserved1;
        public string pwszName;
        public IntPtr pAuthInfo;
        public uint dwReserved2;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct MULTI_QI
    {
        public IntPtr pIID;   // REFIID*
        public IntPtr pItf;   // IUnknown*
        public int hr;        // HRESULT
    }

    internal static class Native
    {
        [DllImport("kernel32.dll")]
        public static extern int GetCurrentThreadId();

        internal const uint EVENT_OBJECT_CREATE = 0x8000;
        internal const uint EVENT_OBJECT_SHOW = 0x8002;
        internal const uint EVENT_SYSTEM_FOREGROUND = 0x0003;
        internal const uint WINEVENT_OUTOFCONTEXT = 0x0000;

        internal delegate void WinEventDelegate(
            IntPtr hWinEventHook, uint eventType, IntPtr hwnd,
            int idObject, int idChild, uint dwEventThread, uint dwmsEventTime);

        [DllImport("user32.dll")]
        internal static extern IntPtr SetWinEventHook(uint eventMin, uint eventMax, IntPtr hmodWinEventProc,
            WinEventDelegate lpfnWinEventProc, uint idProcess, uint idThread, uint dwFlags);

        [DllImport("user32.dll")]
        internal static extern bool UnhookWinEvent(IntPtr hWinEventHook);

        [DllImport("user32.dll", CharSet = CharSet.Unicode)]
        private static extern int GetClassNameW(IntPtr hWnd, StringBuilder lpClassName, int nMaxCount);

        [DllImport("user32.dll", CharSet = CharSet.Unicode)]
        private static extern int GetWindowTextW(IntPtr hWnd, StringBuilder lpString, int nMaxCount);

        internal static string GetClassNameSafe(IntPtr hwnd)
        {
            var sb = new StringBuilder(256);
            try { GetClassNameW(hwnd, sb, sb.Capacity); } catch { }
            return sb.ToString();
        }

        internal static string GetWindowTextSafe(IntPtr hwnd)
        {
            var sb = new StringBuilder(1024);
            try { GetWindowTextW(hwnd, sb, sb.Capacity); } catch { }
            return sb.ToString();
        }

        [DllImport("ole32.dll", CharSet = CharSet.Unicode)]
        private static extern int ProgIDFromCLSID(ref Guid clsid, out IntPtr lplpszProgID);

        internal static string ProgIdFromClsidSafe(Guid clsid)
        {
            IntPtr ptr = IntPtr.Zero;
            try
            {
                int hr = ProgIDFromCLSID(ref clsid, out ptr);
                if (hr != 0 || ptr == IntPtr.Zero)
                    return null;
                string s = Marshal.PtrToStringUni(ptr);
                Marshal.FreeCoTaskMem(ptr);
                ptr = IntPtr.Zero;
                return s;
            }
            catch
            {
                try { if (ptr != IntPtr.Zero) Marshal.FreeCoTaskMem(ptr); } catch { }
                return null;
            }
        }
    }
}



================================================================================
# Arquivo : Program.cs
# Caminho : C:\Projetos\VisualStudio\Banner\CS_3_4\Program.cs
# Tamanho : 344 bytes
# Alterado: 08/27/2025 12:52:31
================================================================================

using System;

namespace ComHookLib
{
    /// <summary>
    /// ComHookLib é uma Class Library injetada; não possui entry point.
    /// Este arquivo existe apenas para manter compatibilidade do projeto.
    /// </summary>
    internal static class Program
    {
        // Sem Main(). Nada a fazer aqui na etapa 1/4.
    }
}



================================================================================
# Arquivo : RelevantFileSink.cs
# Caminho : C:\Projetos\VisualStudio\Banner\CS_3_4\RelevantFileSink.cs
# Tamanho : 2047 bytes
# Alterado: 08/27/2025 19:50:24
================================================================================

// ComHookLib - RelevantFileSink.cs
// Grava apenas linhas "relevantes": kind == "ftaerel" OU hr_name != "S_OK"

using System;
using System.IO;

namespace ComHookLib
{
    internal sealed class RelevantFileSink : ILogSink, IDisposable
    {
        private readonly StreamWriter _sw;

        internal RelevantFileSink(string filePath)
        {
            if (string.IsNullOrWhiteSpace(filePath))
                throw new ArgumentException("filePath inválido.", nameof(filePath));

            var dir = Path.GetDirectoryName(filePath);
            if (!string.IsNullOrEmpty(dir) && !Directory.Exists(dir))
                Directory.CreateDirectory(dir);

            _sw = new StreamWriter(filePath, true);
            _sw.AutoFlush = true;
        }

        public void WriteLine(string line)
        {
            if (line == null) return;

            // critério simples e performático (sem JSON parse):
            // 1) kind == "ftaerel"
            bool isRel = line.IndexOf("\"kind\":\"ftaerel\"", StringComparison.OrdinalIgnoreCase) >= 0;

            // 2) hr_name != "S_OK" (se houver hr_name)
            if (!isRel)
            {
                int idx = line.IndexOf("\"hr_name\":\"", StringComparison.OrdinalIgnoreCase);
                if (idx >= 0)
                {
                    // pega o valor de hr_name rapidamente
                    int start = idx + "\"hr_name\":\"".Length;
                    int end = line.IndexOf('"', start);
                    if (end > start)
                    {
                        var hrName = line.Substring(start, end - start);
                        if (!string.Equals(hrName, "S_OK", StringComparison.OrdinalIgnoreCase))
                            isRel = true;
                    }
                }
            }

            if (isRel)
                _sw.WriteLine(line);
        }

        public void Dispose()
        {
            try { _sw.Dispose(); } catch { /* ignore */ }
        }
    }
}



================================================================================
# Arquivo : RemoteEntry.cs
# Caminho : C:\Projetos\VisualStudio\Banner\CS_3_4\RemoteEntry.cs
# Tamanho : 4307 bytes
# Alterado: 08/27/2025 19:52:30
================================================================================

using System;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Threading;
using EasyHook;

namespace ComHookLib
{
    public sealed class RemoteEntry : IEntryPoint, IDisposable
    {
        private readonly CancellationTokenSource _cts = new CancellationTokenSource();
        private readonly string _sessionId;
        private readonly string _logPath;
        private readonly ILogger _logger;
        private readonly ILogSink _sink; // encadeado com RelevantFileSink quando habilitado
        private UiHook _uiHook;

        private static void SafeAppendShared(string path, string text)
        {
            try
            {
                string dir = Path.GetDirectoryName(path);
                if (!string.IsNullOrEmpty(dir) && !Directory.Exists(dir))
                    Directory.CreateDirectory(dir);

                using (var fs = new FileStream(path, FileMode.Append, FileAccess.Write, FileShare.ReadWrite))
                using (var sw = new StreamWriter(fs, new UTF8Encoding(false)))
                    sw.Write(text);
            }
            catch { }
        }

        private static string BuildRelevantPath(string mainPath)
        {
            try
            {
                var dir = Path.GetDirectoryName(mainPath) ?? "";
                var name = Path.GetFileNameWithoutExtension(mainPath);
                if (string.IsNullOrEmpty(name)) name = "ftaelog";
                var ext = Path.GetExtension(mainPath);
                if (string.IsNullOrEmpty(ext)) ext = ".log";
                return Path.Combine(dir, name + ".relevant" + ext);
            }
            catch
            {
                return mainPath + ".relevant";
            }
        }

        public RemoteEntry(RemoteHooking.IContext context, string logPath)
        {
            _logPath = string.IsNullOrWhiteSpace(logPath)
                ? Path.Combine(Path.GetTempPath(), "ftaelog.log")
                : logPath;

            _sessionId = $"{DateTime.UtcNow:yyyyMMddTHHmmssfffZ}-{Process.GetCurrentProcess().Id}-{Native.GetCurrentThreadId()}";

            // --- T7: bootstrap do sink secundário "relevante" via env var FTA_LOG_RELEVANT ---
            ILogSink baseSink = new ComLogIpc("FTAEPipe", _logPath);
            var enableRelevant = Environment.GetEnvironmentVariable("FTA_LOG_RELEVANT");
            if (string.Equals(enableRelevant, "1", StringComparison.Ordinal))
            {
                var relPath = BuildRelevantPath(_logPath);
                ILogSink relevantSink = new RelevantFileSink(relPath);
                _sink = new MultiSink(baseSink, relevantSink);
                SafeAppendShared(_logPath, "[REMOTE OK] RelevantFileSink habilitado: " + relPath + Environment.NewLine);
            }
            else
            {
                _sink = baseSink;
            }
            // -------------------------------------------------------------------------------

            _logger = new ComLogger(_sink, _sessionId);

            SafeAppendShared(_logPath, "[REMOTE OK] IEntryPoint carregado. PID=" + Process.GetCurrentProcess().Id + " session=" + _sessionId + Environment.NewLine);
            _logger.Info("[REMOTE OK] RemoteEntry iniciado. PID={0} session={1}", Process.GetCurrentProcess().Id, _sessionId);

            _uiHook = new UiHook(_logger);
            _uiHook.Start();

            // Etapa 2/4: instalar hooks COM reais
            ComHooks.Install(_logger);

            _logger.Info("[REMOTE OK] Hooks (UI + COM) instalados.");
        }

        public void Run(RemoteHooking.IContext context, string logPathFromInjector)
        {
            try
            {
                while (!_cts.IsCancellationRequested)
                    Thread.Sleep(1000);
            }
            catch (Exception ex)
            {
                _logger.Error(ex, "RemoteEntry.Run falhou.");
            }
        }

        public void Dispose()
        {
            try
            {
                _cts.Cancel();
                _uiHook?.Dispose();

                var d = _sink as IDisposable;
                if (d != null) d.Dispose();
            }
            catch { }
        }
    }
}



================================================================================
# Arquivo : UiEventDto.cs
# Caminho : C:\Projetos\VisualStudio\Banner\CS_3_4\UiEventDto.cs
# Tamanho : 792 bytes
# Alterado: 08/27/2025 21:27:40
================================================================================

using System;

namespace ComHookLib.Dto
{
    internal class UiEventDto
    {
        public string ts { get; set; } = DateTime.UtcNow.ToString("o");
        public string evt { get; set; }              // "window.create" | "window.show" | "window.foreground"
        public string kind { get; set; }             // "dialog" | "ftaebanner" | "window"
        public int pid { get; set; } = System.Diagnostics.Process.GetCurrentProcess().Id;
        public uint tid { get; set; } = (uint)Native.GetCurrentThreadId();
        public string hwnd { get; set; }             // "0xABCDEF..."
        public string cls { get; set; }              // class name
        public string title { get; set; }            // window text
        public uint threadId { get; set; }
    }
}



================================================================================
# Arquivo : UiHook.cs
# Caminho : C:\Projetos\VisualStudio\Banner\CS_3_4\UiHook.cs
# Tamanho : 4132 bytes
# Alterado: 08/27/2025 21:59:54
================================================================================

using System;

namespace ComHookLib
{
    /// <summary>
    /// Captura eventos de janela para “banner/diálogo” via WinEventHook.
    /// Roda dentro do processo-alvo. Usa ILogger do ComLogger.cs.
    /// </summary>
    internal sealed class UiHook : IDisposable
    {
        private readonly ILogger _logger;

        private Native.WinEventDelegate _cbCreate;
        private Native.WinEventDelegate _cbShow;
        private Native.WinEventDelegate _cbForeground;

        private IntPtr _hCreate;
        private IntPtr _hShow;
        private IntPtr _hForeground;

        public UiHook(ILogger logger)
        {
            if (logger == null) throw new ArgumentNullException("logger");
            _logger = logger;
        }

        public void Start()
        {
            _cbCreate = OnEventCreate;
            _cbShow = OnEventShow;
            _cbForeground = OnEventForeground;

            _hCreate = Native.SetWinEventHook(Native.EVENT_OBJECT_CREATE, Native.EVENT_OBJECT_CREATE, IntPtr.Zero, _cbCreate, 0, 0, Native.WINEVENT_OUTOFCONTEXT);
            _hShow = Native.SetWinEventHook(Native.EVENT_OBJECT_SHOW, Native.EVENT_OBJECT_SHOW, IntPtr.Zero, _cbShow, 0, 0, Native.WINEVENT_OUTOFCONTEXT);
            _hForeground = Native.SetWinEventHook(Native.EVENT_SYSTEM_FOREGROUND, Native.EVENT_SYSTEM_FOREGROUND, IntPtr.Zero, _cbForeground, 0, 0, Native.WINEVENT_OUTOFCONTEXT);

            _logger.Info("UiHook iniciado: create={0} show={1} foreground={2}", _hCreate, _hShow, _hForeground);
        }

        private void OnEventCreate(IntPtr hWinEventHook, uint eventType, IntPtr hwnd, int idObject, int idChild, uint dwEventThread, uint dwmsEventTime)
        {
            if (idObject != 0 || hwnd == IntPtr.Zero) return;
            LogWindow("window.create", hwnd, dwEventThread);
        }

        private void OnEventShow(IntPtr hWinEventHook, uint eventType, IntPtr hwnd, int idObject, int idChild, uint dwEventThread, uint dwmsEventTime)
        {
            if (idObject != 0 || hwnd == IntPtr.Zero) return;
            LogWindow("window.show", hwnd, dwEventThread);
        }

        private void OnEventForeground(IntPtr hWinEventHook, uint eventType, IntPtr hwnd, int idObject, int idChild, uint dwEventThread, uint dwmsEventTime)
        {
            if (idObject != 0 || hwnd == IntPtr.Zero) return;
            LogWindow("window.foreground", hwnd, dwEventThread);
        }

        private void LogWindow(string evt, IntPtr hwnd, uint threadId)
        {
            string cls = Native.GetClassNameSafe(hwnd);
            string title = Native.GetWindowTextSafe(hwnd);

            string kind =
                (!string.IsNullOrEmpty(cls) && (cls.IndexOf("#32770", StringComparison.OrdinalIgnoreCase) >= 0 || cls.IndexOf("Dialog", StringComparison.OrdinalIgnoreCase) >= 0)) ? "dialog" :
                ((!string.IsNullOrEmpty(cls) && cls.IndexOf("FT", StringComparison.OrdinalIgnoreCase) >= 0) || (!string.IsNullOrEmpty(title) && title.IndexOf("Alarm", StringComparison.OrdinalIgnoreCase) >= 0)) ? "ftaebanner" :
                "window";

            var dto = new ComEvents.UiWindowEvent
            {
                ts = DateTime.UtcNow.ToString("o"),
                evt = evt,
                kind = kind,
                pid = System.Diagnostics.Process.GetCurrentProcess().Id,
                tid = (int)Native.GetCurrentThreadId(),
                hwnd = "0x" + ((long)hwnd).ToString("X"),
                cls = cls,
                title = title,
                threadId = threadId
            };

            _logger.Log(dto);
            _logger.Info("UI {0} {1} hwnd={2} cls='{3}' title='{4}'", evt, kind, dto.hwnd, cls, title);
        }

        public void Dispose()
        {
            try { if (_hCreate != IntPtr.Zero) Native.UnhookWinEvent(_hCreate); } catch { }
            try { if (_hShow != IntPtr.Zero) Native.UnhookWinEvent(_hShow); } catch { }
            try { if (_hForeground != IntPtr.Zero) Native.UnhookWinEvent(_hForeground); } catch { }
        }
    }
}



